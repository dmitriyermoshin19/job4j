Контрольные вопросы. Часть 5 GC.

1 Чем java отличается от с++?
**Java** — поддерживает автоматическое управление освобождением динамической памяти. Не поддерживает деструкторы.
**C++** — ручное упраление памятью, поддерживает деструкторы (выполняет освобождение использованных объектом ресурсов).

2 Что такое менеджер памяти?
Менеджер памяти — часть программы, обрабатыващая запросы на выделение и освобождения оперативной памяти.

3 Какой механизм используется в Java для управления памятью?
1) В Java используется автоматическое управление памятью, называется Garbage Collection.
2) Все создаваемые программой объекты находятся в "куче" (heap).
3) Когда объекты занимают в куче много места,
происходит очистка ее от уже не используемых объектов,
т.е. любой объект, обладающий ссылками, остается в памяти,
а все объекты, которые недостижимы из выполняемого кода ввиду отсутствия ссылок на них, удаляются с высвобождением отведенной для них памяти.
4) Сборщик мусора - это отдельный поток, который действует автоматически.

4 Опишите процесс работы сборщика мусора
Все новые объекты, за исключением очень больших, попадают в Young Generation(В Eden, затем в Survivor). Очень большие - могут сразу попасть в Old.

В соответствии с разделением Young Generation и Old Generation процессы сборки мусора разделяются на малую сборку (minor GC), затрагивающую только младшее поколение,
и полную сборку (full GC), которая может затрагивать оба поколения.
Малые сборки выполняются достаточно *часто и удаляют *основную часть мертвых объектов.
Полные сборки выполняются тогда, когда текущий объем выделенной программе памяти близок к *исчерпанию и малой сборкой уже не обойтись.

Объекты из младшего поколения по мере выживания в (малых)сборках мусора *переходят в старшее поколение.
В старшем поколении объект может прожить до окончания работы приложения,
либо будет удален в процессе одной из полных сборок мусора.

5 Какие алгоритмы сборщика вы знаете?
1) Copy Collection

1) На первом этапе (Mark) помечаются неиспользуемые объекты.
2) На втором (Copy) объекты, которые ещё нужны копируется в сегмент survivor.
Сегментов Survivor два, и они меньше Eden. Теперь все объекты, которые мы хотим, чтобы они были сохранены, скопированы в Survivor, и JVM просто удаляет всё из Eden.
Этот алгоритм создаёт кое-что, что называется моментом, «когда мир остановился». Во время выполнения GC все другие процессы в JVM переводятся в состояние паузы, ради того, чтобы никакой из них не попробовал влезть в память после того, как мы скопировали всё оттуда, что привело бы к потере того, что сделано.
Copy Collection работает хорошо в том случае, если у нас небольшое приложение, много мусора и мало полезных объектов.

2) Mark-Sweep-Compact Collection

1) «Mark»: помечаются неиспользуемые объекты.
2) «Sweep»: эти объекты удаляются из памяти.
3) «Compact»: объекты размещаются, занимая свободные слоты(пресуются), что освобождает пространство.


6 Чем отличаются сборщики мусора?
Serial Collector
1) Serial Collector - однопоточный, копирующий, stop-the-world сборщик.
2) Собирает Young Generation, копируя объекты из блоков Eden и From в To.
3) Собирает Old Generation с помощью mark-sweep-compact.

Parallel Collector
1) Parallel Collector - копирующий, stop-the world. Уменьшает pause time по сравнению с Serial за счет многопоточности при сборке Young Generation.
2) Собирает Young Generation, копируя объекты из блоков Eden и From в To. Применяет для этого несколько потоков, тем самым сильно уменьшая pause time.
3) Собирает Old Generation с помощью mark-sweep-compact. Как и в Serial Collector.

CMS - Concurrent Mark Sweep
1) Основная задача CMS Collector - уменьшить время паузы, пусть за счет увеличенного общего времени работы приложения.
2) Young Generation собирается ровно так же, как в Parallel Collector - копирование, Eden, From, To.
3) Сбор Old Generation разбивается на фазы:

3.1) Начальная метка (Initial mark) - короткая stop-the-world, помечаются "живые" объекты.

3.2) Параллельная приложению Marking Phase - проход по ссылкам помеченных объектов и пометка "живыми" объектов.

3.3) Короткая stop-the world фаза Remark. Еще раз пройтись по всем помеченным объектам и проверить, что они не умерли, пока шла предыдущая фаза.

3.4) Наконец, идет параллельная приложению Sweep Phase, во время которой помеченные объекты очищаются, освобождая место.

3.5) Фазы Compact у этого коллектора нет - и в этом его большой минус.

G1
1) Коллектор G1 является заменой Concurent Mark-Sweep (CMS) коллектора и коллектором по-умолчанию с Java 9.
2) Два главных отличия от CMS: (1) Коллектор G1 *группирует живые объекты (compacting), не допуская большой фрагментации памяти(за счет алгоритмаа copy в Old). (2) Коллектор стремится *минимизировать stop-the-world паузы и делает их меньше, чем CMS, за счет разбивания Old Generation на регионы.
3) Коллектор многопоточный, использует параллельные алгоритмы, разбивает память на набор регионов.
4) Каждый регион может быть частью Young или Old generation - по мере надобности.
5) В первую очередь G1 старается освобождать память в регионах с малым количеством живых объектов - отсюда - "Garbage first".
6) Процесс сбора Young Generation и Old Generation в регионе мало чем отличается от работы CMS.
В Young идет копирование из региона Eden в другой регион Survivor (аналог To).
В Old идет initial mark, concurrent mark, remark. Только вместо concurrent sweep идет concurrent copy живых объектов в другой регион, за счет чего и происходит уплотнение.


7 Расскажите про утилиты для анализа памяти
Профилирование - это исследование поведения программы, используя информацию собранную во время выполнения программы.
Цель анализа в том, чтобы определить, какие части программы можно оптимизировать, чтобы *увеличить скорость выполнения
и *уменьшить потребляемую память.
jps выводит запущенные процессы
jmap выводит подробную информацию об указанном запущенном процессе
jstat отслеживает статистику виртуальной машины Java
jstack выводит трассировку стека
jconsole инструмент для мониторинга виртуальной машины Java и приложений Java

8 Что такое ссылки?
1) Ссылки в Java — это указатели на объекты.
2) Иными словами, ссылка - переменная, содержащая *адрес ячейки памяти, где хранится объект.
3) Ссылка может содержать значение null - это значит, что она не ссылается на ячейку в памяти.

9 Какие типы ссылок вы знаете?
1) Strong (сильные)
2) Soft ("мягкие")
3) Weak ("слабые")
4) Phantom ("фантомные")

10 Чем они отличаются?
get() — возвращает объект, на который ссылается эта ссылка;
clear() — удаляет ссылку на объект.

Soft Reference
Если на объект ссылаются только Soft-ссылки, то Garbage Collector может удалить его при *нехватке памяти.
GC гарантировано удалит с кучи все объекты, доступные только по soft-ссылке, перед тем как бросит OutOfMemoryError.

Weak Reference
Если на объект ссылаются только Weak-ссылки, то это сигнал GC удалить этот объект.
Когда GC определяет, что объект доступен только через weak-ссылки, то этот объект «сразу» удаляется из памяти.

Phantom Reference
https://javarush.ru/quests/lectures/questcollections.level04.lecture07
это самые слабые ссылки из всех
используется для сложной процедуры удаления объекта
Метод phantomReference.get() на объекте всегда выдает null, в отличие от weak и soft.
Поэтому фантомные ссылки имеют смысл только с очередью ссылок (ReferenceQueue).
Этот тип ссылок в комбинации с ReferenceQueue позволяет нам узнать, когда объект более недоступен и на него нет других ссылок.
Контракт гарантирует, что ссылка на объект появится в PhantomReference ПОСЛЕ того,
как на него останутся только фантомные ссылки, и это увидит GC,
но ДО того, как объект будет удален из памяти.
Выполнение метода finalize() и добавление phantom-ссылки в ReferenceQueue выполняется в разных запусках GC.
Поэтому для удаления объекта необходимы минимум два запуска GC.

11 Расскажите про класс ReferenceQueue
1) Класс ReferenceQueue - очередь, в которую помещаются объекты ссылок после удаления их объекта сборщиком мусора.
2) Объект ReferenceQueue мы можем передать в конструкторе при создании объекта ссылки.
3) В классе имеются стандартные методы poll() и remove(). Если нет следующего объекта, то poll() сразу возвращает null, а remove() ждет.


12 Расскажите про String pool, Int pool.
String Pool
Благодаря неизменности Strings в Java, JVM может оптимизировать объем памяти, выделенный для них,
сохраняя *только одну копию каждого литерала String в пуле. (Строковые литералы — это набор символов, заключенных в двойные кавычки.)
Этот процесс называется interning.
Когда мы создаем переменную String и присваиваем ей значение, JVM ищет в пуле String с равным значением.
Если найдется, то компилятор Java просто возвратит ссылку на свой адрес памяти, без выделения дополнительной памяти.
Если он не найден, он будет добавлен в пул (интернирован) и его ссылка будет возвращена.

1) String Pool - область памяти, где хранятся объекты строк для многоразового использования.
2) В пул попадают строки, созданные с помощью литералов или строки, на которые вызван string.intern().
3) До Java 7 String Pool находился в PermGen. Не проверялся сборщиком мусора, нет возможности расти.
4) В Java 7+ String pool находится в heap, проверяется сборщиком мусора и может возрастать.
5) Начальный размер пула можно задать в ключах запуска JVM: XX:StringTableSize=N, где N - число хранимых ссылок.
Например: -XX:StringTableSize=4903

Int pool
1) В Java существует пул объектов-оберток примитивов. Он создается статически,
при инициализации соответствующего класса.
2) По спецификации пул используется для переменных:
2.1) byte и boolean;
2.2) int и long в интервале [-128...127]
2.3) char в интервале [0...127]
3) Для таких объектов при автобоксинге (а также при вызове метода valueOf()) не будет создаваться новый объект, а будет возвращаться объект из пула.
4) Например, Integer.valueOf(127) == Integer.valueOf(127), а вот Integer.valueOf(128) != Integer.valueOf(128).
5) Ссылка на кэш (массив со ссылками на объекты пула) - статическая переменная внутреннего статического класса (например, Integer.IntegerCache) или статический член класса (Boolean.TRUE).

13 Расскажите о String.intern.
Когда метод intern() вызван, если пул строк уже содержит строку, эквивалентную к нашему объекту,
что подтверждается методом equals(Object), тогда возвращается ссылка на строку из пула.
В противном случае объект строки добавляется в пул и ссылка на этот объект возвращается.
Этот метод всегда возвращает строку, которая имеет то же значение, что и текущая строка,
но гарантирует что это будет строка из пула уникальных строк.
Таким образом, если str1.equals(str2), то str1.intern() == str2.intern().


14 Расскажите, что такое профайлер?
Java Profiler -это инструмент, отслеживающий конструкции и операции байт-кода Java на уровне JVM.
Эти конструкции и операции кода включают в себя:
 создание объектов, итеративные выполнения (включая рекурсивные вызовы), выполнение методов, выполнение потоков и сборку мусора.


15 Расскажите, как использовать VisualVM.
Java VisualVM - это упрощенный, но надежный инструмент профилирования для приложений Java.
По умолчанию этот инструмент связан с Java Development Kit (JDK).
Его работа основана на других автономных инструментах, предоставляемых в JDK, таких как
JConsole , jstat , jstack , jinfo и jmap .
Java VisualVM поддерживает локальное и удаленное профилирование , а также профилирование памяти и процессора.


16 Расскажите, чем отличается sampling от profiling? Это типы аудита. Режим работы в профайлере.
Sampling -  означает взятие большого количества дампов потока и *анализ трассировки стека.
Обычно это быстрее, не требует изменений времени исполнения в вашем байт-коде (которые могут его сломать), но также менее точен.

Profiling(Профилирование) - означает инструментарий ваших классов и методов, поэтому они «отчитываются» при каждом запуске. Это более точно, так как он учитывает все вызовы инструментального метода, а не только те, которые были получены при завершении дампа.
Однако инструментарий означает, что байт-код ваших классов *изменяется, и это может нарушить вашу программу. Фактически по этой причине использование профилирования на больших серверах приложений (таких как JBoss или WebLogic) часто приводит к тому, что все умирает или зависает.


17 Расскажите о benchmark. Приведите примеры кода.
Тест производительности.
Контрольная задача, необходимая для определения сравнительных характеристик производительности компьютерной системы.


18 Расскажите о методе finalized.
1) Метод finalize() вызывается тогда, когда сборщик мусора уже пометил его доступным для удаления ("мертвый"), но до непосредственного удаления объекта из памяти.
2) Метод предназначен для автоматического освобождения системных ресурсов, связанных с объектом.
3) В случае, если метод finalize() у класса переопределен (от Object.finalize), объект этого класса попадает в отдельную очередь (отдельный поток) на финализацию.
4) Если не переопределен (стандартный Object.finalize) - то не попадает, а сразу очищается.


19 Расскажите о методы clone: Deep clone and shallow clone.
Метод clone() в Java используется для клонирования объектов.
Т.к. Java работает с объектами с помощью ссылок, то простым присваиванием тут не обойдешься, ибо в таком случае копируется лишь адрес, и мы получим две ссылки на один и тот же объект.
Механизм копирования обеспечивает метод clone() класса Object.
clone() действует как конструктор копирования.

Метод clone() класса Object создает и возвращает копию объекта с такими же значениями полей. Object.clone() кидает исключение CloneNotSupportedException если вы пытаетесь клонировать объект не реализующий интерфейс Cloneable.
Реализация по умолчанию метода Object.clone() выполняет неполное/поверхностное (shallow) копирование.
Если вам нужно полное/глубокое (deep) копирование класса то в методе clone() этого класса, после получения клона суперкласса, необходимо скопировать нужные поля.
Синтаксис вызова clone() следующий:
Object copy = obj.clone();
или чаще:
MyClass copy = (MyClass) obj.clone();
Один из недостатков метода clone(), это тот факт, что возвращается тип Object, поэтому требуется нисходящее преобразование типа.
Пару слов о clone() и final полях.
Метод clone() несовместим с final полями. Если вы попробуете клонировать final поле компилятор остановит вас. Единственное решение - отказаться от final.


20 Расскажите о Stack, Heap.
Heap
1) Heap ("куча") - область памяти, выделенная JVM для размещения объектов.
2) Абсолютно все объекты, созданные в ходе работы приложения, размещаются в heap.
3) Мертвые объекты собираются сборщиком мусора.
4) Обычно делится на Young и Old Generation.
5) Работает медленнее, чем Stack память.
6) Если нет места под объект после сборки мусора, выкидывается OutOfMemoryException.

Stack
1) Stack (стек) - область памяти для хранения ЛОКАЛЬНЫХ переменных, создаваемых в методе.
2) Если локально создается объект, то сам объект помещается в Heap, а ссылка на него - в Stack.
3) Stack значительно меньше, чем Heap, скорость доступа - значительно быстрее.
4) Если память стека полностью занята (н-р бесконечная рекурсия), выбрасывается StackOverflowException.
5) Память Stack не требует сборщика мусора - блок полностью очищается при выходе из метода.
6.1) Устройство: по принципу LIFO. Вызван метод - ему выделяется блок стек-памяти и кладется "сверху".
6.2) Внутри вызван подметод - выделяется еще блок памяти и кладется "сверху".
6.3) Всегда доступен только последний, самый "верхний" блок памяти.
6.4) Метод отработал - его верхний блок памяти очищается, становится доступен более нижний блок - обрамляющего метода.


