Контрольные вопросы[857#225761]

Контрольные вопросы. Часть 4. ООД.

1 Что такое SOLID?
Что же такое SOLID-принципы? Это аббревиатура пяти основных принципов дизайна классов в объектно-ориентированном проектировании
Single responsibility,
Open-closed,
Liskov substitution,
Interface segregation
Dependency inversion
SOLID принципы советуют, как проектировать модули, т.е. кирпичики, из которых строится приложение. Цель принципов — проектировать модули, которые:
способствуют изменениям
легко понимаемы
повторно используемы


2 Для чего используются JavaDoc?
Javadoc — генератор документации в HTML-формате из комментариев исходного кода на Java Javadoc. Также предоставляет API для создания доклетов и тэглетов, которые позволяют программисту *анализировать структуру Java-приложения. В каждом случае комментарий должен находиться перед документируемым элементом. @author, @version, @since Многие IDE также используют Javadocs для генерации контекстных описаний API


3 Как писать JavaDoc?
Комментарии документации применяют *для документирования классов, интерфейсов, полей (переменных), конструкторов и методов. В каждом случае комментарий должен находиться *перед документируемым элементом.

Документирование класса, метода или переменной *начинается с комбинации символов /** , после которого следует тело комментариев; заканчивается комбинацией символов */.

В тело комментариев можно вставлять различные *дескрипторы. Каждый дескриптор, начинающийся с символа '@' должен стоять первым в строке. Несколько дескрипторов одного и того же типа необходимо группировать вместе. Встроенные дескрипторы (начинаются с фигурной скобки) можно помещать внутри любого описания.

Утилита javadoc позволяет вставлять *HTML тэги(<b>maker</b>) и использовать специальные ярлыки (*дескрипторы) документирования. НТМL тэги заголовков не используют, чтобы не нарушать стиль файла, сформированного утилитой. Дескрипторы javadoc, начинающиеся со знака @, называются автономными и должны помещаться с начала строки комментария (лидирующий символ * игнорируется). Дескрипторы, начинающиеся с фигурной скобки, например {@code}, называются встроенными и могут применяться внутри описания(/** Функция получения значения поля {@link Product#maker}).


4 Что такое Java code convention? (Соглашения по оформлению кода)
Документ Oracle по правилам оформления кода. Соглашения по офрмлению кода важны для программистов по ряду причин:
80% от стоимости программного обеспечения приходится на его *обслуживание.
Вряд ли какое-либо программное обеспечение все время поддерживается *первоначальным разработчиком.
Соглашения по оформлению кода делают исходный код программ более *удобочитаемым, позволяя инженерам более быстро и тщательно понимать новый код.
Если вы предоствляете исходный код как продукт, вы должны убедится, что он *хорошо оформлен и упакован как любой другой продукт который вы создаете
https://www.oracle.com/technetwork/java/codeconventions-150003.pdf


5 Расскажите про принципы составления Java класса.
Принцип единственной ответственности (SRP). Данный принцип гласит: никогда не должно быть больше одной причины изменить класс.
Принцип открытости/закрытости (OCP) программные сущности (классы, модули, функции и т.п.) должны быть открыты для расширения, но закрыты для изменения.
Принцип подстановки Барбары Лисков (LSP) Это вариация принципа открытости/закрытости, о котором говорилось ранее. Его можно описать так: объекты в программе можно заменить их наследниками без изменения свойств программы.
Принцип разделения интерфейса (ISP) клиенты не должны быть вынуждены реализовывать методы, которые они не будут использовать.
Принцип инверсии зависимостей (DIP) зависимости внутри системы строятся на основе абстракций


6 Что такое SRP?
A module should be responsible to one, and only one, actor. Старая формулировка: A module should have one, and only one, reason to change.

Часто ее трактовали следующим образом: Модуль должен иметь только одну обязанность. И это главное заблуждение при знакомстве с принципами. Все несколько хитрее.

На каждом проекте люди играют разные роли (actor): Аналитик, Проектировщик интерфейсов, Администратор баз данных. Естественно, один человек может играть сразу несколько ролей. В этом принципе речь идет о том, что изменения в модуле может запрашивать одна и *только одна роль. Например, есть модуль, реализующий некую бизнес-логику, запросить изменения в этом модуле может только Аналитик, но никак не DBA или UX.


7 Расскажите о нарушениях принципе SRP?
Например, рассмотрим этот код:

class Animal {
    constructor(name: string){ }
    getAnimalName() { }
    saveAnimal(a: Animal) { }
}
Класс Animal, представленный здесь, описывает какое-то животное. Этот класс нарушает принцип единственной ответственности. Как именно нарушается этот принцип?

В соответствии с принципом единственной ответственности *класс должен решать лишь какую-то одну задачу. Он же решает две, занимаясь работой с хранилищем данных в методе saveAnimal и манипулируя свойствами объекта в конструкторе и в методе getAnimalName.

Как такая структура класса может привести к проблемам?

Если изменится порядок работы с хранилищем данных, используемым приложением, то придётся вносить изменения во *все классы, работающие с хранилищем. Такая архитектура не отличается гибкостью, изменения одних подсистем затрагивают другие, что напоминает эффект домино.

Для того чтобы привести вышеприведённый код в соответствие с принципом единственной ответственности, *создадим ещё один класс, единственной задачей которого является работа с хранилищем, в частности — сохранение в нём объектов класса Animal:

class Animal {
    constructor(name: string){ }
    getAnimalName() { }
}
class AnimalDB {
    getAnimal(a: Animal) { }
    saveAnimal(a: Animal) { }
}


8 Последствия нарушения SRP?
Вместо изенения в одном месте, придется вносить одни и те же изменения в разных местах. Если где-то пропустить, это приведет к ошибке.


9 Что такое OCP?
A software artifact should be open for extension but closed for modification. Старая формулировка: You should be able to extend a classes behavior, without modifying it.

Это определенно может ввести в ступор. Как можно расширить поведение класса без его модификации? В текущей формулировке Роберт Мартин оперирует понятием артефакт, т.е. jar, dll, gem, npm package. Чтобы расширить поведение, нужно воспользоваться *динамическим полиморфизмом.

Например, наше приложение должно отправлять уведомления. Используя dependency inversion, наш модуль объявляет только интерфейс отправки уведомлений, но не реализацию. Таким образом, *логика нашего приложения содержится в одном dll файле, а класс *отправки уведомлений, реализующий интерфейс — в другом. Таким образом, мы можем без изменения (перекомпиляции) модуля с логикой использовать различные способы отправки уведомлений(шаблон Стратегия).

Этот принцип тесно связан с LSP и DIP, которые мы рассмотрим далее.


10 Расскажите о нарушениях принципа OCP?
Это означает, что должна быть возможность изменять *внешнее поведение класса, не внося физические изменения в сам класс. Следуя этому принципу, классы разрабатываются так, чтобы для подстройки класса к конкретным условиям применения было достаточно расширить его и переопределить некоторые функции.

Рассмотри на примере класса OrderRepository.

class OrderRepository
{
	public function load($orderID)
	{
		$pdo = new PDO($this->config->getDsn(), $this->config->getDBUser(), $this->config->getDBPassword());
		$statement = $pdo->prepare('SELECT * FROM `orders` WHERE id=:id');
		$statement->execute(array(':id' => $orderID));
		return $query->fetchObject('Order');
	}
	public function save($order){/*...*/}
	public function update($order){/*...*/}
	public function delete($order){/*...*/}
}
В данном случае хранилищем у нас является база данных. например, MySQL. Но вдруг мы захотели подгружать наши данные о заказах, например, через API стороннего сервера, который, допустим, берёт данные из 1С. Какие изменения нам надо будет внести? Есть несколько вариантов, например, непосредственно изменить методы класса OrderRepository, но этот не соответствует принципу открытости/закрытости, так как класс закрыт для модификации, да и внесение изменений в уже хорошо работающий класс нежелательно. Значит, можно *наследоваться от класса OrderRepository и переопределить все методы, но это решение не самое лучше, так как при добавлении метода в OrderRepository нам придётся добавить аналогичные методы во все его наследники. Поэтому для выполнения принципа открытости/закрытости лучше применить следующее решение — создать *интерфейc IOrderSource, который будет реализовываться соответствующими классами MySQLOrderSource, ApiOrderSource и так далее.


11 Последствия нарушения OCP?
Вместо изенения в одном месте, придется вносить *одни и те же изменения в разных местах. Если где-то пропустить, это приведет к ошибке(как и SRP).


12 Что такое LSP?  (если у оср - акцент делается на базовом классе, то здесь - на наследнике)
Имеет сложное математическое определение, которое можно заменить на: Функции, которые используют базовый тип, должны иметь возможность использовать подтипы базового типа, не зная об этом.

Классический пример нарушения. Есть базовый класс Stack, реализующий следующий интерфейс: length, push, pop. И есть потомок DoubleStack, который дублирует добавляемые элементы. Естественно, класс DoubleStack нельзя использовать вместо Stack.

У этого принципа есть забавное следствие: Объекты, моделирующие сущности, не обязаны реализовывать отношения этих сущностей. Например, у нас есть целые и вещественные числа, причем целые числа — подмножество вещественных. Однако, double состоит из двух int: мантисы и экспоненты. Если бы int наследовал от double, то получилась бы забавная картина: родитель содержит 2-х своих детей.

В качестве второго примера можно привести Generics. Допустим, есть базовый класс Shape и его потомки Circle и Rectangle. И есть некая функция Foo(List list). Мы считаем, что List можно привести к List. Однако, это не так. Допустим, это приведение возможно, но тогда в list можно добавить любую фигуру, например rectangle. А изначально list должен содержать только объекты класса Circle.


13 Расскажите о нарушениях принципа LSP
Его можно описать так: объекты в программе можно заменить их наследниками *без изменения свойств программы. Если оказывается, что в коде *проверяется тип класса, значит принцип подстановки нарушается. Это означает, что класс, разработанный путем расширения на основании базового класса, должен *переопределять его методы так, чтобы *не нарушалась функциональность с точки зрения клиента. То есть, если разработчик расширяет ваш класс и использует его в приложении, он не должен изменять *ожидаемое поведение переопределенных методов.

Предположим у нас есть *класс, который отвечает за валидацию заказа и проверяет, все ли из товаров заказа находятся на складе. У данного класса есть метод isValid который возвращает true или false:

public class OrderStockValidator {

    public boolean isValid(Order order) {
        for (Item item : order.getItems()) {
            if (! item.isInStock()) {
                return false;
            }
        }

        return true;
    }
}
Также предположим, что некоторые заказы нужно валидировать иначе: проверять, все ли товары заказа находятся на складе и все ли товары упакованы. Для этого мы *расширили класс OrderStockValidator классом OrderStockAndPackValidator:

public class OrderStockAndPackValidator extends OrderStockValidator {

    @Override
    public boolean isValid(Order order) {
        for (Item item : order.getItems()) {
            if ( !item.isInStock() || !item.isPacked() ){
                throw new IllegalStateException(
                     String.format("Order %d is not valid!", order.getId())
                );
            }
        }

        return true;
    }
}
Однако в данном классе мы *нарушили принцип LSP, так как вместо того, чтобы вернуть false, если заказ не прошел валидацию, наш метод *бросает исключение IllegalStateException. Клиенты данного кода *не рассчитывают на такое: они ожидают возвращения true или false. Это может привести к ошибкам в работе программы.


14 Последствия нарушения LSP
Неожиданное *поведение классов. *Ошибки в программе при замене на подклассы.

15 Что такое ISP?
Make fine grained interfaces that are client specific.

Под интерфейсом здесь понимается именно Java, C# интерфейс. *Разделение интерфейса облегчает использование и тестирование модулей. Создавайте *узкоспециализированные интерфейсы, предназначенные для конкретного клиента. Клиенты не должны зависеть от интерфейсов, которые они не используют.


14 Расскажите о нарушениях принципе ISP?
Характеризуется следующим утверждением: клиенты *не должны быть вынуждены реализовывать методы, которые они не будут использовать. Этот принцип направлен на устранение недостатков, связанных с реализацией *больших интерфейсов.


15 Последствия нарушения ISP?
Рассмотрим пример. Разработчик Алекс создал интерфейс "отчет" и добавил два метода: generateExcel() и generatedPdf(). Теперь *клиент А хочет использовать этот интерфейс, но он намерен использовать отчеты *только в PDF-формате, а не в Excel. Устроит ли его такая функциональность?

Нет. Он должен будет реализовать два метода, один из которых по большому счету не нужен и существует только благодаря Алексу — дизайнеру программного обеспечения. Клиент воспользуется либо другим интерфейсом, либо оставит поле для Excel пустым.

Так в чем же решение? Оно состоит в *разделении существующего интерфейса на два более мелких. Один — отчет в формате PDF, второй — отчет в формате Excel. Это даст пользователю возможность использовать только необходимый для него функционал.


16 Что такое DIP?
Depend on abstractions, not on concretions.

Модули верхних уровней *не должны зависеть от модулей нижних уровней. Оба типа модулей *должны зависеть от абстракций. Абстракции не должны зависеть от деталей. Детали должны зависеть от абстракций.

Что такое модули верхних уровней? Как определить этот уровень? Как оказалось, все очень просто. Чем ближе модуль *к вводу/выводу, тем ниже уровень модуля. Т.е. модули, работающие с BD, интерфейсом пользователя, низкого уровня. А модули, реализующие *бизнес-логику — высокого уровня.

Что такое зависимость модулей? Это *ссылка на модуль в исходном коде, т.е. import, require и т.п. С помощью динамического полиморфизма в runtime можно обратить эту зависимость.

Есть модуль Logic, реализующий логику, который должен отсылать уведомления. В этом же пакете объявляется интерфейс ISender, который используется Logic. Уровнем ниже, в *другом пакете объявляется ConcreteSender, реализующий ISender. Получается, что в момент компиляции Logic не зависит от ConcreteSender. В runtime, например, через конструктор в Logic устанавливается *экземпляр ConcreteSender.

Отдельно стоит отметить частый вопрос “Зачем плодить абстракции, если мы не собираемся заменять базу данных?”. Логика тут следующая. На старте проекта, мы знаем, что будем использовать реляционную базу данных, и это точно будет Postgresql, а для поиска — ElasticSearch. Мы даже не планируем их менять в будущем. Но мы хотим отложить принятие решений о том, какая будет схема таблиц, какие будут индексы, и т.п. до момента, *пока это не станет проблемой. И на этот момент мы будем обладать достаточной информацией, чтобы принять правильное решение. Также мы можем раньше отладить логику нашего приложения, реализовать интерфейс, собрать обратную связь от заказчика, и минимизировать последующие изменения, ведь многое реализовано только в виде заглушек.


17 Расскажите о нарушениях принципа DIP
Программное обеспечение нужно разрабатывать так, чтобы различные модули были автономными и *соединялись друг с другом с помощью абстракции.

Попробуем продемонстрировать это на примере. Говоря о принципе единственной ответственности, мы рассматривали некоторый OrderProcessor. Взглянем еще раз на код данного класса:

public class OrderProcessor {
    public void process(Order order){

        MySQLOrderRepository repository = new MySQLOrderRepository();
        ConfirmationEmailSender mailSender = new ConfirmationEmailSender();

        if (order.isValid() && repository.save(order)) {
            mailSender.sendConfirmationEmail(order);
        }
    }

}
В данном примере наш OrderProcessor *зависит от двух конкретных *классов MySQLOrderRepository и ConfirmationEmailSender

Правильный вариант:

public class OrderProcessor {

    private MailSender mailSender; // интерфейс
    private OrderRepository repository;

    public OrderProcessor(MailSender mailSender, OrderRepository repository) {
        this.mailSender = mailSender;
        this.repository = repository;
    }

    public void process(Order order){
        if (order.isValid() && repository.save(order)) {
            mailSender.sendConfirmationEmail(order);
        }
    }
}


18 Последствия нарушения DIP
Вместо замены реализации, придется изменять сам класс.



19 Расскажите что такое автоматическое тестирование?
часть процесса тестирования на этапе контроля качества в процессе разработки программного обеспечения. Оно использует *программные средства для выполнения тестов и проверки результатов выполнения, что помогает сократить время тестирования и упростить его процесс.


20 Как в Java осуществляется автоматическое тестирование?
Selenium (Селен). Selenium - это набор различных программных инструментов, каждый из которых имеет свой подход к поддержке автоматизации тестирования веб-приложений на многих платформах.
Тесты JUnit(модульное). JUnit-это простой фреймворк для написания повторяемых тестов. Он является экземпляром архитектуры в xUnit фреймворков для юнит-тестирования.


21 Что такое JUnit? Как использовать для тестирования?
JUnit – это Java фреймворк для тестирования(модульного), т. е. тестирования *отдельных участков кода, например, методов или классов. Тест это отдельный класс.

import org.junit.Test;
import junit.framework.Assert;

public class MathTest {
    @Test
    public void testEquals() {
        Assert.assertEquals(4, 2 + 2);
        Assert.assertTrue(4 == 2 + 2);
    }

    @Test
    public void testNotEquals() {
        Assert.assertFalse(5 == 2 + 2);
    }
}
Подробней обзор JUnit
http://java-online.ru/blog-junit.xhtml


22 Что такое функциональное тестирование чем отличается от модульного?
Обычно используют два вида *автоматических тестов:

Модульное тестирование (тестирование отдельных частей продукта, обычно отдельных функций/методов)(можно как черным ящиком)
Функциональное тестирование — тестирование некого *функционала продукта,
при этом продукт воспринимается(обязательно) как единый «чёрный ящик».

Самое главное — даже успешное прохождение всех юнит-тестов(модульных) *не гарантирует правильной работы продукта: ведь одна и та же функция может быть использована в различных частях системы, в то время как юнит-тест писался для неё с оглядкой лишь на *один вариант использования.

Функциональные тесты *полностью определяют(по крайней мере должны) работоспособность продукта.

И прежде всего нужны *заказчику/руководителю разработки. Юнит тестирование прежде всего нужно самим *разработчикам, для быстрого нахождения ошибок или проверки последствий рефакторинга.


23 Расскажите про принцип TDD
Разработка через тестирование (англ. test-driven development, TDD) — техника разработки программного обеспечения, которая основывается на повторении очень коротких циклов разработки: сначала пишется тест, покрывающий желаемое изменение,
затем пишется код, который позволит пройти тест,
и под конец проводится рефакторинг нового кода к соответствующим стандартам.

24 Расскажите про принцип BDD?
BDD (сокр. от англ. Behavior-driven development, дословно «разработка через поведение») — это методология разработки программного обеспечения,
являющаяся *ответвлением от методологии разработки через тестирование (TDD).

Основной идеей данной методологии является *совмещение в процессе разработки чисто *технических интересов и *интересов бизнеса, позволяя тем самым управляющему персоналу и программистам говорить на *одном языке. Для общения между этими группами персонала используется *предметно-ориентированный язык, основу которого представляют конструкции из естественного языка, *понятные неспециалисту, обычно
 *выражающие поведение программного продукта и ожидаемые результаты.

BDD фокусируется на следующих вопросах:

*С чего начинается процесс.
*Что нужно тестировать, а что нет.
*Сколько проверок должно быть совершено за один раз.
Что *можно назвать проверкой.
Как понять, почему тест *не прошёл.

Исходя из этих вопросов, BDD требует, чтобы
*имена тестов были
 *целыми предложениями, которые начинаются с глагола в сослагательном наклонении
и следовали бизнес целям.
*Описание приемочных тестов
должно вестись на гибком языке пользовательской истории, например:
Как [роль того, чьи бизнес интересы удовлетворяются] я хочу,
чтобы [описание функциональности так, как она должна работать],
для того чтобы [описание выгоды].
Критерии приёмки должны быть описаны через
сценарий, который реализует *пользователь,
чтобы достигнуть результата.


25 Что такое тестирование черным ящиком

тестирование черного ящика – это:
тестирование, как функциональное, так и нефункциональное,
не предполагающее знания внутреннего устройства компонента или системы.
тест-дизайн, основанный на технике черного ящика
 – процедура написания или выбора тест-кейсов
на основе анализа функциональной или нефункциональной спецификации компонента или системы
без знания ее внутреннего устройства.
Почему именно «черный ящик»? Тестируемая программа для тестировщика – как черный непрозрачный ящик, содержания которого он не видит.

Целью этой техники является поиск ошибок в таких категориях:
неправильно реализованные или недостающие функции;
ошибки интерфейса;
ошибки в структурах данных или организации доступа к внешним базам данных;
ошибки поведения или недостаточная производительность системы;

Таким образом, мы не имеем представления о структуре и внутреннем устройстве системы.
Нужно концентрироваться на том, *что программа делает, а не на том, как она это делает.

